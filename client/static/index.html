<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TonightSky v1.0</title>
    <link rel="stylesheet" href="./css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.2.1"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const dateField = document.getElementById('date');
            const timeField = document.getElementById('local_time');
            
            if (!dateField.value) {
                const today = new Date().toISOString().split('T')[0];
                dateField.value = today;
            }
            
            addResizers();
            updateLST();
            
            dateField.addEventListener('input', updateLST);
            timeField.addEventListener('input', updateLST);
        });

        async function updateLST() {
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;

            if (!longitude || !date || !local_time || !timezone) return;

            try {
                const response = await fetch('http://127.0.0.1:5000/api/calculate_lst', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ longitude, date, local_time, timezone })
                });

                if (!response.ok) throw new Error('Failed to calculate LST');
                
                const data = await response.json();
                document.getElementById('lst_display').textContent = data.LST;
            } catch (error) {
                console.error("Error fetching LST:", error);
            }
        }

        async function listObjects() {
            const latitude = document.getElementById('latitude').value;
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;
            const filter_expression = document.getElementById('filter_expression').value;
            const catalogs = {};
            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                catalogs[cb.value] = cb.checked;
            });

            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = "";

            try {
                const response = await fetch('http://127.0.0.1:5000/api/list_objects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude, longitude, date, local_time, timezone, filter_expression, catalogs })
                });

                if (!response.ok) throw new Error('Failed to fetch data');
                
                const data = await response.json();
                populateTable(data);

            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Failed to load objects. Please try again.");
            }
        }

        function populateTable(data) {
            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = "";

            data.forEach(obj => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${obj.Name}</td><td>${obj.RA}</td><td>${obj.Dec}</td><td>${obj["Transit Time"]}</td>
                    <td>${obj["Relative TT"]}</td><td>${obj["Before/After"]}</td><td>${obj.Altitude}</td>
                    <td>${obj.Azimuth}</td><td>${obj["Alt Name"]}</td><td>${obj.Type}</td>
                    <td>${obj.Magnitude}</td><td>${obj.Info}</td><td>${obj.Catalog}</td>
                `;
                row.addEventListener('dblclick', () => {
                    const objectName = obj.Name.replace(/\s+/g, '');
                    const astrobinUrl = `https://www.astrobin.com/search/?q=${encodeURIComponent(objectName)}`;
                    window.open(astrobinUrl, '_blank');
                });
                row.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                    showContextMenu(event.pageX, event.pageY, obj);
                });
                tableBody.appendChild(row);
            });
        }

        let sortDirection = 1;
        function sortTableByColumn(columnIndex) {
            const tableBody = document.getElementById('resultsTableBody');
            const rows = Array.from(tableBody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex].innerText;
                const cellB = b.cells[columnIndex].innerText;

                if (!isNaN(cellA) && !isNaN(cellB)) {
                    return (cellA - cellB) * sortDirection;
                } else {
                    return cellA.localeCompare(cellB) * sortDirection;
                }
            });

            sortDirection = -sortDirection;
            rows.forEach(row => tableBody.appendChild(row));
        }

        function addResizers() {
            document.querySelectorAll('#resultsTable th').forEach((th, index) => {
                const resizer = document.createElement('div');
                resizer.classList.add('resizer');
                th.appendChild(resizer);
                resizer.addEventListener('mousedown', e => initResize(e, index));
            });
        }

        function initResize(e, index) {
            const startX = e.pageX;
            const startWidth = e.target.parentElement.offsetWidth;

            function resizeColumn(e) {
                const newWidth = Math.max(startWidth + (e.pageX - startX), 50);
                document.querySelectorAll(`#resultsTable th:nth-child(${index + 1}), #resultsTable td:nth-child(${index + 1})`)
                    .forEach(cell => {
                        cell.style.width = `${newWidth}px`;
                    });
            }

            function stopResize() {
                document.removeEventListener('mousemove', resizeColumn);
                document.removeEventListener('mouseup', stopResize);
            }

            document.addEventListener('mousemove', resizeColumn);
            document.addEventListener('mouseup', stopResize);
        }

        async function fetchAltitudeData(object) {
            try {
                const response = await fetch('http://127.0.0.1:5000/api/altitude_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latitude: document.getElementById('latitude').value,
                        longitude: document.getElementById('longitude').value,
                        ra: object.RA,
                        dec: object.Dec,
                        date: document.getElementById('date').value,
                        timezone: document.getElementById('timezone').value
                    })
                });

                if (!response.ok) throw new Error('Failed to fetch altitude data');

                const data = await response.json();
                showAltitudeGraph(object, data);
            } catch (error) {
                console.error("Error fetching altitude data:", error);
            }
        }

        function parseTimeToMinutes(timeStr, referenceSunsetTime) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            let totalMinutes = hours * 60 + minutes;

            // If the time is after midnight but before sunrise (e.g., 00:30), treat it as the next day.
            if (totalMinutes < referenceSunsetTime) {
                totalMinutes += 1440;  // Add 24 hours in minutes to shift to the next day
            }

            return totalMinutes;
        }

        function showAltitudeGraph(object, data) {
            // Set the modal title dynamically
            const titleElement = document.getElementById('chartTitle');
            titleElement.textContent = `${object.Name.replace(/\s+/g, ' ').trim()} - Transit Time: ${data.transit_time}`;

            // Display the graph modal
            document.getElementById('graphModal').style.display = 'block';

            // Get the canvas context
            const ctx = document.getElementById('altitudeChart').getContext('2d');

            // Clear any existing chart on the canvas
            if (window.altitudeChartInstance) {
                window.altitudeChartInstance.destroy();
            }

            // Calculate the minutes from the first time in the data for x-values
            const firstTime = data.times[0];
            const [firstHour, firstMinute] = firstTime.split(':').map(Number);
            const firstTimeInMinutes = firstHour * 60 + firstMinute;

            const timeInMinutes = data.times.map(time => {
                const [hour, minute] = time.split(':').map(Number);
                let totalMinutes = hour * 60 + minute;

                // Adjust times past midnight to ensure continuity
                if (totalMinutes < firstTimeInMinutes) {
                    totalMinutes += 1440; // Add 24 hours in minutes for times after midnight
                }

                return totalMinutes - firstTimeInMinutes;
            });

            // Map event times (dawn, dusk, etc.) to minutes from the first time, scaled for 10-minute intervals
            const sunsetMinutes = (parseTimeToMinutes(data.sunset, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const sunriseMinutes = (parseTimeToMinutes(data.sunrise, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const dawnMinutes = (parseTimeToMinutes(data.astronomical_dawn, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const duskMinutes = (parseTimeToMinutes(data.astronomical_dusk, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const transitMinutes = (parseTimeToMinutes(data.transit_time, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const midnightMinutes = ((24 * 60 - firstTimeInMinutes) % 1440) / 10; // Calculate midnight position

            const verticalLines = [
                { position: transitMinutes, label: 'Transit', color: 'red' },
                { position: midnightMinutes, label: 'Midnight', color: 'green' },
            ];

            // Custom plugin for shading, vertical lines, and plot adjustments
// Define the custom plugin for dynamic shading, grid, and labels
            const customPlugin = {
                id: 'customPlugin',
                beforeDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    ctx.save();

                    // Shading for sunset to dusk, dawn to sunrise, and black for night
                    const drawBackground = (start, end, color) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = color;
                        ctx.fillRect(startX, chartArea.top, endX - startX, chartArea.bottom - chartArea.top);
                    };

                    const drawGradient = (start, end, gradient) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(startX, chartArea.top, endX - startX, chartArea.bottom - chartArea.top);
                    };

                    // Gradient for sunset to dusk
                    const lightToDarkGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(sunsetMinutes),
                        0,
                        scales.x.getPixelForValue(duskMinutes),
                        0
                    );
                    lightToDarkGradient.addColorStop(0, '#d3d3d3');
                    lightToDarkGradient.addColorStop(1, '#404040');
                    drawGradient(sunsetMinutes, duskMinutes, lightToDarkGradient);

                    // Gradient for dawn to sunrise
                    const darkToLightGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(dawnMinutes),
                        0,
                        scales.x.getPixelForValue(sunriseMinutes),
                        0
                    );
                    darkToLightGradient.addColorStop(0, '#404040');
                    darkToLightGradient.addColorStop(1, '#d3d3d3');
                    drawGradient(dawnMinutes, sunriseMinutes, darkToLightGradient);

                    // Black shading for dusk to dawn
                    drawBackground(duskMinutes, dawnMinutes, 'black');

                    // Vertical lines for Transit and Midnight
                    const verticalLines = [
                        { position: transitMinutes, label: 'Transit', color: 'red' },
                        { position: midnightMinutes, label: 'Midnight', color: 'green' }
                    ];

                    verticalLines.forEach(line => {
                        const xPosition = scales.x.getPixelForValue(line.position);

                        // Draw vertical line
                        ctx.beginPath();
                        ctx.moveTo(xPosition, chartArea.top);
                        ctx.lineTo(xPosition, chartArea.bottom);
                        ctx.strokeStyle = line.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw label above the chart
                        ctx.fillStyle = line.color;
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(line.label, xPosition, chartArea.top - 10);
                    });

                    // Horizontal line at 0 altitude
                    const yZero = scales.y.getPixelForValue(0);
                    ctx.beginPath();
                    ctx.moveTo(chartArea.left, yZero);
                    ctx.lineTo(chartArea.right, yZero);
                    ctx.strokeStyle = 'green';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.restore();
                },
                beforeDatasetsDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const data = chart.data.datasets[0].data;

                    ctx.save();

                    for (let i = 0; i < data.length - 1; i++) {
                        const xStart = scales.x.getPixelForValue(i);
                        const yStart = scales.y.getPixelForValue(data[i]);
                        const xEnd = scales.x.getPixelForValue(i + 1);
                        const yEnd = scales.y.getPixelForValue(data[i + 1]);

                        // Determine the zone for the segment
                        const isDarkZone = i >= duskMinutes && i <= dawnMinutes;
                        ctx.strokeStyle = isDarkZone ? '#ffffff' : '#d3d3d3';
                        ctx.stroke();

                        // Draw the segment
                        ctx.beginPath();
                        ctx.moveTo(xStart, yStart);
                        ctx.lineTo(xEnd, yEnd);
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            };

            // Chart.js Configuration
            window.altitudeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeInMinutes,
                    datasets: [{
                        data: data.altitudes,
                        borderWidth: 1,
                        pointRadius: 0, // Remove circles on plot points
                        borderColor: 'transparent',
                        /*
                        borderColor: function(context) {
                            const xValue = context.dataIndex/10;
                            return (xValue >= duskMinutes && xValue <= dawnMinutes) ? '#ffffff' : '#ffffff'; // Light gray in dark zone
                        },
                        */
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    layout: {
                        padding: {
                            top: 20 // Add space above the graph for labels
                        }
                    },
                    plugins: {
                        legend: { display: false },
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Altitude (°)' },
                            grid: {
                                color: function(context) {
                                    const minutes = timeInMinutes[context.tick.value];
                                    return (minutes >= duskMinutes && minutes <= dawnMinutes) ? '#404040' : '#404040';
                                }
                            }
                        },
                        x: {
                            title: { display: true, text: 'Local Time (HH)' },
                            ticks: {
                                callback: function(value, index) {
                                    const hour = Math.floor((timeInMinutes[index] + firstTimeInMinutes) / 60) % 24;
                                    return (timeInMinutes[index] % 60 === 0) ? `${hour}` : '';
                                },
                                autoSkip: false,
                                maxRotation: 0
                            },
                            grid: {
                                color: function(context) {
                                    const minutes = timeInMinutes[context.tick.value];
                                    // Determine whether the grid line is between dusk and dawn
                                    const isNight = minutes/10 >= duskMinutes && minutes/10 <= dawnMinutes;

                                    // Return color based on whether it's night or day
                                    if (minutes % 30 === 0) {
                                        return isNight ? '#404040' : '#808080'; // Dark gray for night, light gray for day
                                    }
                                    return 'transparent'; // Hide grid lines not on 30-minute intervals
                                },
                                borderDash: function(context) {
                                    const minutes = timeInMinutes[context.tick.value];
                                    return (minutes % 60 === 0) ? [] : [5, 5];
                                }
                            }
                        }
                    }
                },
                plugins: [customPlugin]
            });
        }


        function showContextMenu(x, y, object) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;

            document.getElementById('graphOption').onclick = () => {
                fetchAltitudeData(object);
                closeContextMenu();
            };
        }

        function closeContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        function closeModal() {
            document.getElementById('graphModal').style.display = 'none';
        }

        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu.style.display === 'block' && !contextMenu.contains(e.target)) {
                closeContextMenu();
            }
        });
    </script>
</head>
<body>
    <div id="resultsContainer">
        <h1>TonightSky v1.0</h1>
        <form onsubmit="event.preventDefault(); listObjects();" id="topForm">
            <div class="form-row">
                <label class="label-input">Latitude: <input type="text" id="latitude" value="-33.713611"></label>
                <label class="label-input">Longitude: <input type="text" id="longitude" value="151.090278"></label>
                <label class="label-input">Timezone: <input type="text" id="timezone" value="Australia/Sydney"></label>
            </div>
            
            <!-- Second Row: Date, Local Time, LST -->
            <div class="form-row">
                <label class="label-input">Date: <input type="date" id="date"></label>
                <label class="label-input">Local Time: <input type="time" id="local_time" value="22:00"></label>
                <label class="label-input">LST: <span id="lst_display">00:00:00</span></label>
            </div>
            
            <!-- Third Row: Catalog Filters -->
            <div class="form-row">
                <span class="label">Catalog:</span>
                <label><input type="checkbox" name="catalogs" value="Messier" checked> Messier</label>
                <label><input type="checkbox" name="catalogs" value="NGC"> NGC</label>
                <label><input type="checkbox" name="catalogs" value="IC"> IC</label>
                <label><input type="checkbox" name="catalogs" value="Caldwell"> Caldwell</label>
                <label><input type="checkbox" name="catalogs" value="Abell"> Abell</label>
                <label><input type="checkbox" name="catalogs" value="Sharpless"> Sharpless</label>
            </div>
            
            <!-- Fourth Row: Filter Query -->
            <div class="form-row full-width">
                <label>Filter Query:</label>
                <input type="text" id="filter_expression" class="wide-input" placeholder="e.g., altitude > 30 and magnitude < 6">
            </div>
                
            <!-- Button Row -->
            <div class="button-row">
                <button type="submit">
                    List Objects
                </button>
            </div>
        </form>

        <!-- Results Table -->
        <table id="resultsTable">
            <thead>
                <tr>
                    <th onclick="sortTableByColumn(0)">Name</th>
                    <th onclick="sortTableByColumn(1)">RA</th>
                    <th onclick="sortTableByColumn(2)">Dec</th>
                    <th onclick="sortTableByColumn(3)">Transit Time</th>
                    <th onclick="sortTableByColumn(4)">Relative TT</th>
                    <th onclick="sortTableByColumn(5)">Before/After</th>
                    <th onclick="sortTableByColumn(6)">Altitude</th>
                    <th onclick="sortTableByColumn(7)">Azimuth</th>
                    <th onclick="sortTableByColumn(8)">Alt Name</th>
                    <th onclick="sortTableByColumn(9)">Type</th>
                    <th onclick="sortTableByColumn(10)">Magnitude</th>
                    <th onclick="sortTableByColumn(11)">Info</th>
                    <th onclick="sortTableByColumn(12)">Catalog</th>
                </tr>
            </thead>
            <tbody id="resultsTableBody">
                <!-- Table rows will be appended here by JavaScript -->
            </tbody>
        </table>
    </div>

    <!-- Chart Modal -->
    <div id="graphModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="chartTitle" class="chart-title"></h3> <!-- Title outside the chart -->
            <canvas id="altitudeChart"></canvas>
        </div>
    </div>

    <!-- Context Menu for right-click actions -->
    <div id="contextMenu" style="display: none; position: absolute; background: #fff; border: 1px solid #ccc; z-index: 1000;">
        <div id="graphOption" style="padding: 8px; cursor: pointer;">Graph</div>
    </div>
</body>
</html>
