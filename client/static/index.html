<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TonightSky v1.0</title>
    <link rel="stylesheet" href="./css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"> 
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.2.1"></script>
    <style>
        /* Existing styles */
        #getLocation {
          background-color: green; /* Initial button color */
          border: none;
          padding: 8px 16px;
          cursor: pointer;
          transition: background-color 0.3s ease; /* Add a transition for a smooth effect */
        }
    
        #getLocation:active {
          background-color: darkgreen; /* Change color while pressed */
        }
    </style>
    
    <script>
        // constants
        const ENABLE_LOGGING = false;
    //    const APP_SERVER = 'http://127.0.0.1:5000/api/';
        const APP_SERVER = 'https://app.microconcepts.com.au/tonightsky/api/';

        const HORIZON_ALTITUDE = 25; // Constant for the horizontal line altitude
        // Define constants for gradient start and end colors
        const GRADIENT_LIGHT = '#f8f8f8'; // Light gradient color
        const GRADIENT_DARK = '#101010';  // Dark gradient color
        const GRID_DAY = '#808080';  // Dark gradient color
        const GRID_NIGHT = '#404040';  // Dark gradient color

        ///*
        const logOutput = document.getElementById('logOutput');
        function logMessage(message) {
            if (ENABLE_LOGGING) {
                console.log(message); // Log to console
                const logOutput = document.getElementById('logOutput');
                if (logOutput) {
                    logOutput.style.display = 'block'; // Ensure log div is visible
                    logOutput.textContent += message + '\n';
                    logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll to the bottom
                }
            }
        }
        //*/

        ////////
        logMessage(`Using API server: ${APP_SERVER}`);

        function setTodayDate() {
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone; // Get user's timezone
            const today = new Date().toLocaleDateString('en-CA', { timeZone: timezone }); // Format in ISO 8601 (yyyy-MM-dd)

            const dateInput = document.getElementById('date'); // Target the date input field
            if (dateInput) {
                dateInput.value = today; // Set the value to today's date
            } else {
                console.error('Date input field not found!');
            }
        }

        async function errorHandler(response, customMessage) {
            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = errorData.error; // Extract from the JSON
                document.getElementById("errorMessage").textContent = `${customMessage}: ${errorMessage}`;
                document.getElementById("errorMessage").style.display = "inline-block";
                return true; // Signal error was handled
            } else {
                document.getElementById("errorMessage").style.display = "none";
                return false; // Signal no error was found
            }
        }

        /////////////////////////////////////////////////////////////////////////////////
        //
        //  Setup app events that except for events related to list items
        //
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Settings are loaded from localStorage

            const dateField = document.getElementById('date');
            const timeField = document.getElementById('local_time');
            const contextMenu = document.getElementById('contextMenu');

            // Call the function to set today's date
            setTodayDate();

            // Add event listeners for LST updates and saving settings
            addResizers();
            updateLST();
            dateField.addEventListener('input', updateLST);
            timeField.addEventListener('input', updateLST);
            document.getElementById('latitude').addEventListener('input', saveSettings);
            document.getElementById('longitude').addEventListener('input', saveSettings);
            document.getElementById('timezone').addEventListener('input', saveSettings);
            document.getElementById('local_time').addEventListener('input', saveSettings);
            document.getElementById('filter_expression').addEventListener('input', saveSettings);
            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                cb.addEventListener('change', saveSettings);
            });

            // Close the context menu on click outside
            document.addEventListener('click', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    closeContextMenu();
                }
            });

            // Fetch version from server
            fetch(`${APP_SERVER}version`)
                .then(async response => {
                    if (await errorHandler(response, 'Failed to fetch version')) {
                         document.getElementById('version').textContent = 'vUnknown'; // Fallback if fetching fails
                         return;
                    }
                    return response.json();
                })
                .then(data => {
                    document.getElementById('version').textContent = `v${data.version}`;
                })
                .catch(error => {
                    console.error('Error fetching version:', error);
                    document.getElementById('version').textContent = 'vUnknown'; // Fallback if fetching fails
                });


            // Timezone dropdown logic
            (() => {
                const timezoneInput = document.getElementById('timezone');
                const timezoneSelect = document.getElementById('timezoneDropdown');

                if (!timezoneInput || !timezoneSelect) {
                    console.error('Timezone input or dropdown not found!');
                    return;
                }

                // Detect if the user is on a mobile touch device
                const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                let isDropdownFocused = false; // Flag to detect focus on dropdown

                // Populate the timezone dropdown
                let timezones = [];
                try {
                    timezones = Intl.supportedValuesOf('timeZone');
                } catch (error) {
                    console.warn('Intl.supportedValuesOf is not supported in this browser. Using fallback.');
                    timezones = [
                        'UTC', 'Europe/London', 'Europe/Paris', 'America/New_York',
                        'America/Los_Angeles', 'Australia/Sydney', 'Asia/Tokyo',
                    ];
                }

                timezones.forEach(zone => {
                    const option = document.createElement('option');
                    option.value = zone;
                    option.textContent = zone;
                    timezoneSelect.appendChild(option);
                });

                // Restore saved timezone from settings
                const savedTimezone = localStorage.getItem('timezone');
                if (savedTimezone) {
                    timezoneInput.value = savedTimezone;

                    const matchingOption = Array.from(timezoneSelect.options).find(
                        option => option.value === savedTimezone
                    );
                    if (matchingOption) matchingOption.selected = true;
                }

                // Filter dropdown options based on input
                timezoneInput.addEventListener('input', () => {
                    const filter = timezoneInput.value.toLowerCase();
                    let hasMatches = false;

                    Array.from(timezoneSelect.options).forEach(option => {
                        if (option.value.toLowerCase().includes(filter)) {
                            option.style.display = '';
                            hasMatches = true;
                        } else {
                            option.style.display = 'none';
                        }
                    });

                    timezoneSelect.style.display = hasMatches ? 'block' : 'none';
                });

                // Show dropdown on focus
                timezoneInput.addEventListener('focus', () => {
                    timezoneSelect.style.display = 'block'; // Show dropdown

                    // Find the option matching the current input value
                    const currentValue = timezoneInput.value.toLowerCase();
                    const matchingOption = Array.from(timezoneSelect.options).find(
                        (option) => option.value.toLowerCase() === currentValue
                    );

                    // If a matching option exists, focus it
                    if (matchingOption) {
                        timezoneSelect.value = matchingOption.value; // Select the option
                    }
                });

                // Handle dropdown click selection
                timezoneSelect.addEventListener('click', (event) => {
                    const selectedOption = event.target;
                    if (selectedOption.tagName === 'OPTION') {
                        timezoneInput.value = selectedOption.value;
                        timezoneSelect.style.display = 'none';
                        saveSettings(); // Optional: Save the selection
                    }
                });

                // Add touchstart event for touch devices
                if (isMobile) {
                    timezoneSelect.addEventListener('touchstart', (event) => {
                        const selectedOption = event.target;
                        if (selectedOption.tagName === 'OPTION') {
                            timezoneInput.value = selectedOption.value;
                            timezoneSelect.style.display = 'none';
                            saveSettings(); // Optional: Save the selection
                        }
                    });

                    timezoneSelect.addEventListener('change', (event) => {
                        timezoneInput.value = event.target.value;
                        timezoneSelect.style.display = 'none';
                        saveSettings();
                    });

                    timezoneSelect.addEventListener('focusout', (event) => {
                        timezoneSelect.style.display = 'none';
                    });
                } else {
                    // Update dropdown focus state when interacting with it
                    timezoneSelect.addEventListener('mousedown', () => {
                        isDropdownFocused = true;
                    });
                    timezoneSelect.addEventListener('mouseup', () => {
                        isDropdownFocused = false;
                    });

                    // Close dropdown only if neither input nor dropdown are focused
                    timezoneInput.addEventListener('blur', () => {
                        setTimeout(() => {
                            if (!isDropdownFocused) {
                                timezoneSelect.style.display = 'none';
                            }
                        }, 150);
                    });
                }
            })();

            // Get Current Location Button
            const getLocationButton = document.createElement('button');
//            getLocationButton.innerHTML = '<i class="fas fa-location-arrow"></i>'; // Use Font Awesome icon
            getLocationButton.id = 'getLocation';
            // Create the icon element
            getLocationButton.style.backgroundImage = "url('./img/location.png')";
            getLocationButton.style.backgroundSize = "contain";
            getLocationButton.style.backgroundRepeat = "no-repeat";
            getLocationButton.style.backgroundPosition = "center";
            getLocationButton.style.backgroundColor = "transparent"; // Set background color to transparent
            getLocationButton.style.border = "none"; // Remove any default border
            getLocationButton.style.width = "40px"; // Adjust as needed
            getLocationButton.style.height = "40px"; // Adjust as needed
            getLocationButton.title = "Get current location and timezone";

            // Add the icon to the button
//            getLocationButton.appendChild(icon); 

            // Add click event listener to the button
            getLocationButton.addEventListener('click', () => {
                event.preventDefault(); // Prevent form submission
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(showPosition, showError);
                } else {
                    alert("Geolocation is not supported by this browser.");
                }
            });

            // Function to show the position (latitude and longitude)
            function showPosition(position) {
                document.getElementById('latitude').value = position.coords.latitude;
                document.getElementById('longitude').value = position.coords.longitude;
                // Get the user's current timezone
                const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                document.getElementById('timezone').value = userTimezone;
                saveSettings();
                updateLST();
            }

            // Function to show an error if geolocation fails
            function showError(error) {
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        alert("User denied the request for Geolocation.");
                        break;
                    case error.POSITION_UNAVAILABLE:
                        alert("Location information is unavailable.");
                        break;
                    case error.TIMEOUT:
                        alert("The request to get user location timed out.");
                        break;
                    case error.UNKNOWN_ERROR:
                        alert("An unknown error occurred.");
                        break;
                }
            }

            // Append the button INSIDE the label, after the input field
            const firstFormRow = document.querySelector('.form-row'); // Select the first .form-row
            firstFormRow.appendChild(getLocationButton); 
            // Align the button with the bottom of the timezone input
            // Use Flexbox for alignment
            firstFormRow.style.display = 'flex';
            firstFormRow.style.alignItems = 'flex-end'; 

            // Explicitly set the button's height and remove margins
            const timezoneInput = document.getElementById('timezone');
            getLocationButton.style.height = timezoneInput.offsetHeight + 'px';
            getLocationButton.style.marginTop = '0'; 
            getLocationButton.style.marginBottom = '0'; 

            // Global keydown listener for the Enter key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent default behavior
                    listObjects(); // Always run the listObjects() function
                }
            });

            const helpButton = document.getElementById('helpButton');
            helpButton.addEventListener('click', (event) => {
                event.preventDefault(); // Prevent default behavior

                // Define max dimensions
                const maxWidth = 900;  // Maximum width of the popup
                const maxHeight = 1200; // Maximum height of the popup

                // Set initial dimensions
                const width = Math.min(window.innerWidth * 0.9, maxWidth);
                const height = Math.min(window.innerHeight * 0.9, maxHeight);

                // Calculate center position
                const screenLeft = window.screenLeft || window.screenX;
                const screenTop = window.screenTop || window.screenY;
                const screenWidth = window.innerWidth || document.documentElement.clientWidth;
                const screenHeight = window.innerHeight || document.documentElement.clientHeight;

                const left = screenLeft + (screenWidth - width) / 2;
                const top = screenTop + (screenHeight - height) / 2;

                // Open the popup
                const helpWindow = window.open(
                    'help.html',
                    '_blank',
                    `width=${width},height=${height},top=${top},left=${left},resizable=yes,scrollbars=yes`
                );

                if (!helpWindow) {
                    alert('Popup blocked! Please allow popups for this website.');
                    return;
                }

                // Wait for the popup to load and resize it
                const adjustWindow = () => {
                    try {
                        const helpDocument = helpWindow.document;

                        // Ensure the content is loaded
                        if (!helpDocument.body || helpDocument.body.scrollHeight === 0) {
                            setTimeout(adjustWindow, 50); // Retry after a short delay
                            return;
                        }

                        const contentHeight = helpDocument.body.scrollHeight;
                        const contentWidth = helpDocument.body.scrollWidth;

                        // Resize the popup to fit content within max dimensions
                        const newWidth = Math.min(contentWidth + 30, maxWidth); // Add some padding
                        const newHeight = Math.min(contentHeight + 30, maxHeight); // Add some padding

                        helpWindow.resizeTo(newWidth, newHeight);

                        // Re-center the window
                        const newLeft = screenLeft + (screenWidth - newWidth) / 2;
                        const newTop = screenTop + (screenHeight - newHeight) / 2;
                        helpWindow.moveTo(newLeft, newTop);
                    } catch (error) {
                        console.error('Error adjusting help window:', error);
                    }
                };

                helpWindow.onload = adjustWindow;

                // Fallback in case `onload` doesn't trigger correctly
                setTimeout(adjustWindow, 500);
            });

            logMessage("DOM fully loaded");
            logMessage(`Using API server: ${APP_SERVER}`);
        });


        
        async function updateLST() {
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;

            if (!longitude || !date || !local_time || !timezone) return;

            try {
                const response = await fetch(`${APP_SERVER}calculate_lst`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ longitude, date, local_time, timezone })
                });

                if (await errorHandler(response, 'Failed to calculate LST')) return;
                
                const data = await response.json();
                document.getElementById('lst_display').textContent = data.LST;
            } catch (error) {
                console.error("Error fetching LST:", error);
            }
        }

        function updateObjectCount() {
            const tableBody = document.getElementById('resultsTableBody');
            const rowCount = tableBody.querySelectorAll('tr').length;
            document.getElementById('objectCount').textContent = `Object Count: ${rowCount}`;
        }

        async function listObjects() {
            const latitude = document.getElementById('latitude').value;
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;
            const filter_expression = document.getElementById('filter_expression').value;
            const catalogs = {};
            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                catalogs[cb.value] = cb.checked;
            });

            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = ""; // Clear previous results

            const loadingPopup = document.getElementById('loadingPopup');
            loadingPopup.style.display = 'block';

            try {
                const response = await fetch(`${APP_SERVER}list_objects`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude, longitude, date, local_time, timezone, filter_expression, catalogs })
                });

                if (await errorHandler(response, 'Failed to fetch data')) return;

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let accumulatedData = "";
                let rowCount = 0; // Track the number of rows added

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    accumulatedData += decoder.decode(value, { stream: true });
                    const lines = accumulatedData.split("\n");
                    accumulatedData = lines.pop(); // Keep incomplete line for the next chunk

                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                const obj = JSON.parse(line);
                                appendRow(obj); // Append each row to the table
                                rowCount++; // Increment row count
                                // Update object count every 100 items
                                if (rowCount % 10 === 0) {
                                    objectCount.textContent = `Object Count: ${rowCount}`;
                                }
                            } catch (e) {
                                console.error("Error parsing streamed line:", e);
                            }
                        }
                    }
                }
                // Final count update
                objectCount.textContent = `Object Count: ${rowCount}`;

            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Failed to load objects. Please try again.");
            } finally {
                loadingPopup.style.display = 'none';
            }
        }

        function appendRow(obj) {
            const row = createRow(obj);
            addRowEventListeners(row, obj);
            const tableBody = document.getElementById('resultsTableBody');
            tableBody.appendChild(row);
        }

        function createRow(obj) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${obj.Name}</td><td>${obj.RA}</td>
                <td>${obj.Dec}</td>
                <td>${obj["Transit Time"]}</td>
                <td>${obj["Transit Alt"]}</td>
                <td>${obj["Direction"]}</td>
                <td>${obj["Relative TT"]}</td>
                <td>${obj["Before/After"]}</td>
                <td class="altitude-cell">${obj.Altitude}</td>
                <td>${obj.Azimuth}</td>
                <td>${obj["Alt Name"]}</td>
                <td>${obj.Type}</td>
                <td>${obj.Magnitude}</td>
                <td>${obj["Size"]}</td>
                <td>${obj.Info}</td>
                <td>${obj.Catalog}</td>
            `;
            return row;
        }

        function addRowEventListeners(row, obj) {
            // Add double-click event to open Astrobin link
            row.addEventListener('dblclick', () => {
                const name = obj.Name.replace(/\s+/g, '').toLowerCase(); // Remove spaces and lowercase, e.g., "M 83" → "m83"
                const match = name.match(/([a-z]+)(\d+)/); // Match prefix (letters) and number (digits)
                if (match) {
                    const prefix = match[1];
                    const number = match[2];
                    const formattedName = `${prefix}-${number}`; // e.g., "m-83"
                    const telescopiusUrl = `https://telescopius.com/deep-sky-objects/${formattedName}`;
                    window.open(telescopiusUrl, '_blank');
                } else {
                    console.error('Object name does not match expected pattern:', obj.Name);
                }
            });

            // Add context menu event to show the custom context menu
            row.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                showContextMenu(event.pageX, event.pageY, obj);
            }, { passive: false });

            // Highlight row on click
            row.addEventListener('click', () => {
                const previouslyHighlightedRow = document.querySelector('.highlighted-row');
                if (previouslyHighlightedRow) {
                    previouslyHighlightedRow.classList.remove('highlighted-row');
                }
                row.classList.add('highlighted-row');
            });

            // Add click and touchstart events to the altitude cell
            const altitudeCell = row.querySelector('.altitude-cell');
            altitudeCell.addEventListener('click', () => fetchAltitudeData(obj), { passive: true });
            altitudeCell.addEventListener('touchstart', (event) => {
                event.preventDefault();
                fetchAltitudeData(obj);
            }, { passive: false });
        }


        function resizeWindowToFitTable() {
            const table = document.getElementById('resultsTable');
            const tableWidth = table.offsetWidth;
            const tableHeight = table.offsetHeight;

            // Set the document's body dimensions to match the table
            document.body.style.width = tableWidth + 'px';
            document.body.style.height = tableHeight + 'px';

            // Trigger a window resize event to force the browser to recalculate layout
            window.dispatchEvent(new Event('resize'));
        }


        let sortDirection = 1;
        function sortTableByColumn(columnIndex) {
            const tableBody = document.getElementById('resultsTableBody');
            const rows = Array.from(tableBody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex].innerText;
                const cellB = b.cells[columnIndex].innerText;

                if (!isNaN(cellA) && !isNaN(cellB)) {
                    return (cellA - cellB) * sortDirection;
                } else {
                    return cellA.localeCompare(cellB) * sortDirection;
                }
            });

            sortDirection = -sortDirection;
            rows.forEach(row => tableBody.appendChild(row));
        }

        function addResizers() {
            document.querySelectorAll('#resultsTable th').forEach((th, index) => {
                const resizer = document.createElement('div');
                resizer.classList.add('resizer');
                th.appendChild(resizer);
                resizer.addEventListener('mousedown', e => initResize(e, index));
            });
        }

        function initResize(e, index) {
            const startX = e.pageX;
            const startWidth = e.target.parentElement.offsetWidth;

            function resizeColumn(e) {
                const newWidth = Math.max(startWidth + (e.pageX - startX), 50);
                document.querySelectorAll(`#resultsTable th:nth-child(${index + 1}), #resultsTable td:nth-child(${index + 1})`)
                    .forEach(cell => {
                        cell.style.width = `${newWidth}px`;
                    });
            }

            function stopResize() {
                document.removeEventListener('mousemove', resizeColumn);
                document.removeEventListener('mouseup', stopResize);
            }

            document.addEventListener('mousemove', resizeColumn);
            document.addEventListener('mouseup', stopResize);
        }
        
        function saveSettings() {
            const settings = {
                latitude: document.getElementById('latitude').value,
                longitude: document.getElementById('longitude').value,
                timezone: document.getElementById('timezone').value,
                local_time: document.getElementById('local_time').value,
                catalog_filter: Array.from(document.querySelectorAll('input[name="catalogs"]')).reduce((acc, cb) => {
                    acc[cb.value] = cb.checked;
                    return acc;
                }, {}),
                filter_query: document.getElementById('filter_expression').value
            };
            localStorage.setItem('tonightSkySettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('tonightSkySettings'));
            if (settings) {
                document.getElementById('latitude').value = settings.latitude || '';
                document.getElementById('longitude').value = settings.longitude || '';
                document.getElementById('timezone').value = settings.timezone || '';
                document.getElementById('local_time').value = settings.local_time || '';
                document.getElementById('filter_expression').value = settings.filter_query || '';
                
                const catalogFilters = settings.catalog_filter || {};
                document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                    cb.checked = !!catalogFilters[cb.value];
                });
            }
        }

        async function fetchAltitudeData(object) {
            logMessage("Fetching altitude data");
            try {
                const response = await fetch(`${APP_SERVER}altitude_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latitude: document.getElementById('latitude').value,
                        longitude: document.getElementById('longitude').value,
                        ra: object.RA,
                        dec: object.Dec,
                        date: document.getElementById('date').value,
                        timezone: document.getElementById('timezone').value
                    })
                });

                if (await errorHandler(response, 'Failed to fetch altitude data')) return;

                const data = await response.json();
                logMessage("Have altitude data:");

                showAltitudeGraph(object, data);
                logMessage("showing altitude data")
            } catch (error) {
                console.error("Error fetching altitude data:", error);
                logMessage("Error fetching altitude data:", error);
            }
        }

        function parseTimeToMinutes(timeStr, referenceSunsetTime) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            let totalMinutes = hours * 60 + minutes;

            // If the time is after midnight but before sunrise (e.g., 00:30), treat it as the next day.
            if (totalMinutes < referenceSunsetTime) {
                totalMinutes += 1440;  // Add 24 hours in minutes to shift to the next day
            }

            return totalMinutes;
        }

        function showAltitudeGraph(object, data) {
            // Set the modal title dynamically
            const titleElement = document.getElementById('chartTitle');
            const maxAltitude = Math.max(...data.altitudes); // Calculate the max altitude
            titleElement.textContent = `${object.Name.replace(/\s+/g, ' ').trim()} - Transit Time: ${object["Transit Time"]}- Apex: ${maxAltitude.toFixed(1)}°`;

            // Display the graph modal
            document.getElementById('graphModal').style.display = 'block';

            // Get the canvas context
            const ctx = document.getElementById('altitudeChart').getContext('2d');

            // Clear any existing chart on the canvas
            if (window.altitudeChartInstance) {
                window.altitudeChartInstance.destroy();
            }

            // Calculate the minutes from the first time in the data for x-values
            const firstTime = data.times[0];
            const [firstHour, firstMinute] = firstTime.split(':').map(Number);
            const firstTimeInMinutes = firstHour * 60 + firstMinute;
            const hourStart = firstHour * 60; // Minutes at the start of the hour, e.g., 19:00 = 1140 minutes

            const timeInMinutes = data.times.map(time => {
                const [hour, minute] = time.split(':').map(Number);
                let totalMinutes = hour * 60 + minute;

                // Adjust times past midnight to ensure continuity
                if (totalMinutes < firstTimeInMinutes) {
                    totalMinutes += 1440; // Add 24 hours in minutes for times after midnight
                }

                return totalMinutes - firstTimeInMinutes;
            });


            // Map event times (dawn, dusk, etc.) to minutes from the first time, scaled for 10-minute intervals
            const sunsetMinutes = (parseTimeToMinutes(data.sunset, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const sunriseMinutes = (parseTimeToMinutes(data.sunrise, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const dawnMinutes = (parseTimeToMinutes(data.astronomical_dawn, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const duskMinutes = (parseTimeToMinutes(data.astronomical_dusk, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const transitMinutes = (parseTimeToMinutes(data.transit_time, firstTimeInMinutes) - firstTimeInMinutes) / 10;

            const midnightMinutes = (parseTimeToMinutes("00:00", firstTimeInMinutes) - (firstTimeInMinutes)) / 10;

            const verticalLines = [
                { position: transitMinutes, label: 'Transit', color: 'red' },
                { position: midnightMinutes, label: 'Midnight', color: 'green' },
            ];

            // Custom plugin for shading, vertical lines, and plot adjustments
            // Define the custom plugin for dynamic shading, grid, and labels
            const customPlugin = {
                id: 'customPlugin',
                beforeDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const { left, right, top, bottom } = chartArea;
                    ctx.save();

                    // Shading for background
                    const drawBackground = (start, end, color) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = color;
                        ctx.fillRect(startX, top, endX - startX, bottom - top);
                    };

                    const drawGradient = (start, end, gradient) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(startX, top, endX - startX, bottom - top);
                    };

                    // Gradient for sunset to dusk
                    const lightToDarkGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(sunsetMinutes),
                        0,
                        scales.x.getPixelForValue(duskMinutes),
                        0
                    );
                    lightToDarkGradient.addColorStop(0, GRADIENT_LIGHT);
                    lightToDarkGradient.addColorStop(1, GRADIENT_DARK);
                    drawGradient(sunsetMinutes, duskMinutes, lightToDarkGradient);

                    // Gradient for dawn to sunrise
                    const darkToLightGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(dawnMinutes),
                        0,
                        scales.x.getPixelForValue(sunriseMinutes),
                        0
                    );
                    darkToLightGradient.addColorStop(0, GRADIENT_DARK);
                    darkToLightGradient.addColorStop(1, GRADIENT_LIGHT);
                    drawGradient(dawnMinutes, sunriseMinutes, darkToLightGradient);

                    // Black shading for dusk to dawn
                    drawBackground(duskMinutes, dawnMinutes, 'black');

                    // Draw vertical lines for Transit and Midnight
                    const verticalLines = [
                        { position: transitMinutes, label: 'Transit', color: 'red' },
                        { position: midnightMinutes, label: 'Midnight', color: 'green' },
                        { position: duskMinutes, label: 'Dusk', color: 'rgba(0, 0, 255, 0.4)' },
                        { position: dawnMinutes, label: 'Dawn', color: 'rgba(0, 0, 255, 0.4)' }
                    ];

                    verticalLines.forEach(line => {
                        const xPosition = scales.x.getPixelForValue(line.position);

                        // Draw vertical line
                        ctx.beginPath();
                        ctx.moveTo(xPosition, top);
                        ctx.lineTo(xPosition, bottom);
                        ctx.strokeStyle = line.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw label above the chart
                        ctx.fillStyle = line.color;
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(line.label, xPosition, top - 10);
                    });

                    // Horizontal grid lines dynamically
                    const yTicks = scales.y.ticks;

                    yTicks.forEach((tick) => {
                        const yPosition = scales.y.getPixelForValue(tick.value);

                        // Daytime: left to dusk
                        ctx.beginPath();
                        ctx.moveTo(left, yPosition);
                        ctx.lineTo(scales.x.getPixelForValue(duskMinutes), yPosition);
                        ctx.strokeStyle = GRID_DAY; // Light gray for daytime
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Nighttime: dusk to dawn
                        ctx.beginPath();
                        ctx.moveTo(scales.x.getPixelForValue(duskMinutes), yPosition);
                        ctx.lineTo(scales.x.getPixelForValue(dawnMinutes), yPosition);
                        ctx.strokeStyle = GRID_NIGHT; // Dark gray for nighttime
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Daytime: dawn to right
                        ctx.beginPath();
                        ctx.moveTo(scales.x.getPixelForValue(dawnMinutes), yPosition);
                        ctx.lineTo(right, yPosition);
                        ctx.strokeStyle = GRID_DAY; // Light gray for daytime
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });

                    // Add a thick horizontal line at HORIZON_ALTITUDE degrees altitude
                    // Define constants
                    const maxAltitude = scales.y.max; // Maximum value of the y-axis

                    // Draw horizontal line at HORIZON_ALTITUDE if within the visible range
                    if (HORIZON_ALTITUDE <= maxAltitude) {
                        const yHorizon = scales.y.getPixelForValue(HORIZON_ALTITUDE);
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yHorizon);
                        ctx.lineTo(chartArea.right, yHorizon);
                        ctx.strokeStyle = 'blue';
                        ctx.lineWidth = 2; // Thicker line
                        ctx.stroke();
                    }

                    // Draw custom x-axis ticks and grid lines
                    // Loop through ticks to draw custom grid and labels
                    const labelPadding = 20; // Space below the graph for labels
                    timeInMinutes.forEach((minute, index) => {
                        const xPosition = scales.x.getPixelForValue(index);

                        // Only draw vertical grid lines at hourly intervals
                        if ((minute + firstTimeInMinutes) % 60 === 0) {
                            const isNight = minute >= duskMinutes && minute <= dawnMinutes;

                            // Draw vertical line
                            ctx.beginPath();
                            ctx.moveTo(xPosition, top);
                            ctx.lineTo(xPosition, bottom);
                            ctx.strokeStyle = isNight ? GRID_NIGHT : GRID_DAY; // Dark gray for night, light gray for day
                            ctx.lineWidth = 1;
                            ctx.stroke();

                            // Draw x-axis hour labels
                            const hour = Math.floor((minute + firstTimeInMinutes) / 60) % 24;
                            ctx.fillStyle = '#808080'; // Text color
                            ctx.font = '12px Arial'; // Adjust font size if necessary
                            ctx.textAlign = 'center';
                            ctx.fillText(`${hour}`, xPosition, bottom + labelPadding); // Position below the axis
                        }
                    });
                    // Draw x-axis title
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#808080'; // Light gray text color for title
                    ctx.textAlign = 'center';
                    ctx.fillText('Local Time (HH)', (chartArea.left + chartArea.right) / 2, chartArea.bottom + 35);


                    // Draw plot line dynamically
                    const data = chart.data.datasets[0].data;

                    for (let i = 0; i < data.length - 1; i++) {
                        const xStart = scales.x.getPixelForValue(i);
                        const yStart = scales.y.getPixelForValue(data[i]);
                        const xEnd = scales.x.getPixelForValue(i + 1);
                        const yEnd = scales.y.getPixelForValue(data[i + 1]);

                        // Determine the zone for the segment
                        const isDarkZone = i >= duskMinutes && i <= dawnMinutes;
                        const isBelowHorizon = data[i] < HORIZON_ALTITUDE || data[i + 1] < HORIZON_ALTITUDE;
                        ctx.strokeStyle = isBelowHorizon ? '#c0c0c0' : isDarkZone ? '#00ff00' : '#c0c0c0'; // Adjust colors dynamically

                        ctx.beginPath();
                        ctx.moveTo(xStart, yStart);
                        ctx.lineTo(xEnd, yEnd);
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            };

            // Chart.js Configuration
            window.altitudeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeInMinutes,
                    datasets: [{
                        data: data.altitudes,
                        borderWidth: 1,
                        pointRadius: 0, // Remove circles on plot points
                        borderColor: 'transparent',
                        /*
                        borderColor: function(context) {
                            const xValue = context.dataIndex/10;
                            return (xValue >= duskMinutes && xValue <= dawnMinutes) ? '#ffffff' : '#ffffff'; // Light gray in dark zone
                        },
                        */
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    layout: {
                        padding: {
                            top: 25, // Add space above the graph for labels
                            bottom: 35,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: { display: false },
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Altitude (°)' },
                            grid: {
                                color: 'transparent', // Prevent Chart.js from drawing default grid lines
                                drawTicks: false,     // Optional: Prevent ticks on the grid if you want full control
                            }
                        },
                        x: {
                            display: false,
                            title: { display: false, text: 'Local Time (HH)' },
                            grid: {
                                color: 'transparent', // Prevent Chart.js from drawing default grid lines
                                drawTicks: false,     // Optional: Prevent ticks on the grid if you want full control
                            }
                        }
                    }
                },
                plugins: [customPlugin]
            });
        }


        function showContextMenu(x, y, object) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;

            document.getElementById('graphOption').onclick = () => {
                fetchAltitudeData(object);
                closeContextMenu();
            };
        }

        function closeContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        function closeModal() {
            logMessage("close altitude data")

            document.getElementById('graphModal').style.display = 'none';
        }

    </script>
</head>
<body>
    <div id="resultsContainer">
        <header id="appHeader">
            <h1>TonightSky</h1>
            <div class="header-right">
                <span id="version">v4.0</span>
                <button id="helpButton" title="Help" aria-label="Open Help Information">?</button>
            </div>
        </header>
        <form onsubmit="event.preventDefault(); listObjects();" id="topForm">
            <div class="form-row">
                <label class="label-input" for="latitude" aria-label="Enter Latitude">Latitude: <input type="text" id="latitude" value="-33.713611"></label>
                <label class="label-input" for="longitude" aria-label="Enter Longitude">Longitude: <input type="text" id="longitude" value="151.090278"></label>
                <label class="dropdown-input" for="timezone" aria-label="Select Timezone">
                    Timezone:
                    <input type="text" id="timezone" placeholder="Search timezones..." autocomplete="off" />
                    <select id="timezoneDropdown" size="5" style="display: none; width: 100%;"></select>
                </label>
            </div>
            
            <!-- Second Row: Date, Local Time, LST -->
            <div class="form-row">
                <label class="label-input" for="date" aria-label="Select Date">Date: <input type="date" id="date"></label>
                <label class="label-input" for="local_time" aria-label="Set Local Time">Local Time: <input type="time" id="local_time" value="00:00:00"></label>
                <label class="label-input" aria-label="Local Sidereal Time">LST: <span id="lst_display">00:00:00</span></label>
            </div>
            
            <!-- Third Row: Catalog Filters -->
            <div class="form-row">
                <span class="label">Catalog:</span>
                <label for="catalogMessier" aria-label="Toggle Messier Catalog"><input type="checkbox" name="catalogs" id="catalogMessier" value="Messier" checked> Messier</label>
                <label for="catalogNGC" aria-label="Toggle NGC Catalog"><input type="checkbox" name="catalogs" id="catalogNGC" value="NGC"> NGC</label>
                <label for="catalogIC" aria-label="Toggle IC Catalog"><input type="checkbox" name="catalogs" id="catalogIC" value="IC"> IC</label>
                <label for="catalogCaldwell" aria-label="Toggle Caldwell Catalog"><input type="checkbox" name="catalogs" id="catalogCaldwell" value="Caldwell"> Caldwell</label>
                <label for="catalogAbell" aria-label="Toggle Abell Catalog"><input type="checkbox" name="catalogs" id="catalogAbell" value="Abell"> Abell</label>
                <label for="catalogSharpless" aria-label="Toggle Sharpless Catalog"><input type="checkbox" name="catalogs" id="catalogSharpless" value="Sharpless"> Sharpless</label>
            </div>
            
            <!-- Fourth Row: Filter Query -->
            <div class="form-row full-width">
                <label for="filter_expression" aria-label="Enter Filter Query">Filter Query:</label>
                <input type="text" id="filter_expression" class="wide-input" placeholder="e.g., altitude > 30 and magnitude < 6">
            </div>
                
            <!-- Button Row -->
            <div class="button-row">
                <button type="submit" id="listObjectsButton" aria-label="List Celestial Objects">List Objects</button>
                <span id="objectCount" class="object-count-label" aria-label="Current Object Count">Object Count: 0</span>
                <span id="errorMessage" style="color: red; margin-left:10px; display:none;"></span>
            </div>
        </form>
        <!-- Log Output 
        <div id="logOutput" style="white-space: pre-wrap; font-family: monospace; background: #f0f0f0; padding: 10px; border: 1px solid #ccc; height: 200px; overflow-y: auto;">
        </div> -->
    
        <!-- Results Table -->
        <div id="tableContainer">
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th onclick="sortTableByColumn(0)">Name</th>
                        <th onclick="sortTableByColumn(1)">RA</th>
                        <th onclick="sortTableByColumn(2)">Dec</th>
                        <th onclick="sortTableByColumn(3)">Transit Time</th>
                        <th onclick="sortTableByColumn(4)">Transit Alt</th>
                        <th onclick="sortTableByColumn(5)">Direction</th>
                        <th onclick="sortTableByColumn(6)">Relative TT</th>
                        <th onclick="sortTableByColumn(7)">Before/After</th>
                        <th onclick="sortTableByColumn(8)">Altitude</th>
                        <th onclick="sortTableByColumn(9)">Azimuth</th>
                        <th onclick="sortTableByColumn(10)">Alt Name</th>
                        <th onclick="sortTableByColumn(11)">Type</th>
                        <th onclick="sortTableByColumn(12)">Magnitude</th>
                        <th onclick="sortTableByColumn(13)">Size</th>
                        <th onclick="sortTableByColumn(14)">Info</th>
                        <th onclick="sortTableByColumn(15)">Catalog</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody">
                    <!-- Rows will be dynamically appended here -->
                </tbody>
            </table>
        </div>

    </div>

    <!-- Chart Modal -->
    <div id="graphModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="chartTitle" class="chart-title"></h3> <!-- Title outside the chart -->
            <canvas id="altitudeChart"></canvas>
        </div>
    </div>

    <!-- Context Menu for right-click actions -->
    <div id="contextMenu" style="display: none; position: absolute; background: #fff; border: 1px solid #ccc; z-index: 1000;">
        <div id="graphOption" style="padding: 8px; cursor: pointer;">Graph</div>
    </div>

    <div id="loadingPopup">
        <div class="loading-icon"></div>
        <p>Loading data, please wait...</p>
        <div class="help-text">
            <!-- Tips -->
            <p class="tip"><strong>Tip:</strong> Double-click to go to Astrobin</p>
            <p class="tip"><strong>Tip:</strong> Right-click or click on altitude cell to show an altitude graph</p>
            
            <!-- Notes -->
            <p class="note"><strong>Note:</strong> Times between 00:00 to 11:59 are treated as the next day</p>
            <p class="note"><strong>Note:</strong> Loading a large catalog (e.g., 10,000 objects) may take 60+ seconds.</p>
            <p class="note"><strong>Note:</strong> Objects with -ve altitude at the nominated time are not included in the results.</p>
        </div>
    </div>
</body>
</html>
