<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TonightSky v1.0</title>
    <link rel="stylesheet" href="./css/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.2.1"></script>
    <script>
        // constants

        const APP_SERVER = 'http://127.0.0.1:5000/api/';
        // const APP_SERVER = 'https://app.microconcepts.com.au/tonightsky/api/';

        const HORIZON_ALTITUDE = 25; // Constant for the horizontal line altitude
        // Define constants for gradient start and end colors
        const GRADIENT_LIGHT = '#f8f8f8'; // Light gradient color
        const GRADIENT_DARK = '#101010';  // Dark gradient color
        const GRID_DAY = '#808080';  // Dark gradient color
        const GRID_NIGHT = '#404040';  // Dark gradient color

        ////////
        console.log(`Using API server: ${APP_SERVER}`);

        document.addEventListener('DOMContentLoaded', () => {
            loadSettings(); // Settings are loaded from localStorage

            const dateField = document.getElementById('date');
            const timeField = document.getElementById('local_time');
            
            if (!dateField.value) {
                const today = new Date().toISOString().split('T')[0];
                dateField.value = today;
            }
            
            addResizers();
            updateLST();
            
            dateField.addEventListener('input', updateLST);
            timeField.addEventListener('input', updateLST);
            // Save settings when inputs change
            document.getElementById('latitude').addEventListener('input', saveSettings);
            document.getElementById('longitude').addEventListener('input', saveSettings);
            document.getElementById('timezone').addEventListener('input', saveSettings);
            document.getElementById('local_time').addEventListener('input', saveSettings);
            document.getElementById('filter_expression').addEventListener('input', saveSettings);

            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                cb.addEventListener('change', saveSettings);
            });

        });

        async function updateLST() {
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;

            if (!longitude || !date || !local_time || !timezone) return;

            try {
                const response = await fetch(`${APP_SERVER}calculate_lst`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ longitude, date, local_time, timezone })
                });

                if (!response.ok) throw new Error('Failed to calculate LST');
                
                const data = await response.json();
                document.getElementById('lst_display').textContent = data.LST;
            } catch (error) {
                console.error("Error fetching LST:", error);
            }
        }

/////////////////////////////////////////////////////
        async function listObjects() {
            const latitude = document.getElementById('latitude').value;
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;
            const filter_expression = document.getElementById('filter_expression').value;
            const catalogs = {};
            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                catalogs[cb.value] = cb.checked;
            });

            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = ""; // Clear previous results

            const loadingPopup = document.getElementById('loadingPopup');
            loadingPopup.style.display = 'block';

            try {
                const response = await fetch(`${APP_SERVER}list_objects`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude, longitude, date, local_time, timezone, filter_expression, catalogs })
                });

                if (!response.ok) throw new Error('Failed to fetch data');

                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let accumulatedData = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    accumulatedData += decoder.decode(value, { stream: true });
                    const lines = accumulatedData.split("\n");
                    accumulatedData = lines.pop(); // Keep incomplete line for the next chunk

                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                const obj = JSON.parse(line);
                                appendRow(obj); // Append each row to the table
                            } catch (e) {
                                console.error("Error parsing streamed line:", e);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Failed to load objects. Please try again.");
            } finally {
                loadingPopup.style.display = 'none';
            }
        }

        function appendRow(obj) {
            const tableBody = document.getElementById('resultsTableBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${obj.Name}</td><td>${obj.RA}</td><td>${obj.Dec}</td><td>${obj["Transit Time"]}</td>
                <td>${obj["Relative TT"]}</td><td>${obj["Before/After"]}</td><td>${obj.Altitude}</td>
                <td>${obj.Azimuth}</td><td>${obj["Alt Name"]}</td><td>${obj.Type}</td>
                <td>${obj.Magnitude}</td><td>${obj.Info}</td><td>${obj.Catalog}</td>
            `;

            // Add double-click event to open Astrobin link
            row.addEventListener('dblclick', () => {
                const objectName = obj.Name.replace(/\s+/g, ''); // Remove spaces for Astrobin search
                const astrobinUrl = `https://www.astrobin.com/search/?q=${encodeURIComponent(objectName)}`;
                window.open(astrobinUrl, '_blank');
            });

            // Add context menu event to show the custom context menu
            row.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                showContextMenu(event.pageX, event.pageY, obj);
            });

            tableBody.appendChild(row);
        }

        function resizeWindowToFitTable() {
            const table = document.getElementById('resultsTable');
            const tableWidth = table.offsetWidth;
            const tableHeight = table.offsetHeight;

            // Set the document's body dimensions to match the table
            document.body.style.width = tableWidth + 'px';
            document.body.style.height = tableHeight + 'px';

            // Trigger a window resize event to force the browser to recalculate layout
            window.dispatchEvent(new Event('resize'));
        }

///////////////////////////////////////////////////


        async function listObjectsX() {
            const latitude = document.getElementById('latitude').value;
            const longitude = document.getElementById('longitude').value;
            const date = document.getElementById('date').value;
            const local_time = document.getElementById('local_time').value;
            const timezone = document.getElementById('timezone').value;
            const filter_expression = document.getElementById('filter_expression').value;
            const catalogs = {};
            document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                catalogs[cb.value] = cb.checked;
            });

            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.getElementById('progressContainer');
            const tableBody = document.getElementById('resultsTableBody');

            tableBody.innerHTML = "";

            try {

                // Show the loading popup
                const loadingPopup = document.getElementById('loadingPopup');
                loadingPopup.style.display = 'block';
                
                const response = await fetch(`${APP_SERVER}list_objects`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude, longitude, date, local_time, timezone, filter_expression, catalogs })
                });

                if (!response.ok) throw new Error('Failed to fetch data');
                
                const data = await response.json();

                populateTable(data);

            } catch (error) {
                console.error("Error fetching data:", error);
                alert("Failed to load objects. Please try again.");
                progressContainer.style.display = 'none';
            } finally {
                // Hide the loading popup
                loadingPopup.style.display = 'none';
            }
        }

        function populateTable(data) {
            const tableBody = document.getElementById('resultsTableBody');
            tableBody.innerHTML = "";

            data.forEach(obj => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${obj.Name}</td><td>${obj.RA}</td><td>${obj.Dec}</td><td>${obj["Transit Time"]}</td>
                    <td>${obj["Relative TT"]}</td><td>${obj["Before/After"]}</td><td>${obj.Altitude}</td>
                    <td>${obj.Azimuth}</td><td>${obj["Alt Name"]}</td><td>${obj.Type}</td>
                    <td>${obj.Magnitude}</td><td>${obj.Info}</td><td>${obj.Catalog}</td>
                `;
                row.addEventListener('dblclick', () => {
                    const objectName = obj.Name.replace(/\s+/g, '');
                    const astrobinUrl = `https://www.astrobin.com/search/?q=${encodeURIComponent(objectName)}`;
                    window.open(astrobinUrl, '_blank');
                });
                row.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                    showContextMenu(event.pageX, event.pageY, obj);
                });
                tableBody.appendChild(row);
            });
        }



        let sortDirection = 1;
        function sortTableByColumn(columnIndex) {
            const tableBody = document.getElementById('resultsTableBody');
            const rows = Array.from(tableBody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex].innerText;
                const cellB = b.cells[columnIndex].innerText;

                if (!isNaN(cellA) && !isNaN(cellB)) {
                    return (cellA - cellB) * sortDirection;
                } else {
                    return cellA.localeCompare(cellB) * sortDirection;
                }
            });

            sortDirection = -sortDirection;
            rows.forEach(row => tableBody.appendChild(row));
        }

        function addResizers() {
            document.querySelectorAll('#resultsTable th').forEach((th, index) => {
                const resizer = document.createElement('div');
                resizer.classList.add('resizer');
                th.appendChild(resizer);
                resizer.addEventListener('mousedown', e => initResize(e, index));
            });
        }

        function initResize(e, index) {
            const startX = e.pageX;
            const startWidth = e.target.parentElement.offsetWidth;

            function resizeColumn(e) {
                const newWidth = Math.max(startWidth + (e.pageX - startX), 50);
                document.querySelectorAll(`#resultsTable th:nth-child(${index + 1}), #resultsTable td:nth-child(${index + 1})`)
                    .forEach(cell => {
                        cell.style.width = `${newWidth}px`;
                    });
            }

            function stopResize() {
                document.removeEventListener('mousemove', resizeColumn);
                document.removeEventListener('mouseup', stopResize);
            }

            document.addEventListener('mousemove', resizeColumn);
            document.addEventListener('mouseup', stopResize);
        }
        
        function saveSettings() {
            const settings = {
                latitude: document.getElementById('latitude').value,
                longitude: document.getElementById('longitude').value,
                timezone: document.getElementById('timezone').value,
                local_time: document.getElementById('local_time').value,
                catalog_filter: Array.from(document.querySelectorAll('input[name="catalogs"]')).reduce((acc, cb) => {
                    acc[cb.value] = cb.checked;
                    return acc;
                }, {}),
                filter_query: document.getElementById('filter_expression').value
            };
            localStorage.setItem('tonightSkySettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('tonightSkySettings'));
            if (settings) {
                document.getElementById('latitude').value = settings.latitude || '';
                document.getElementById('longitude').value = settings.longitude || '';
                document.getElementById('timezone').value = settings.timezone || '';
                document.getElementById('local_time').value = settings.local_time || '';
                document.getElementById('filter_expression').value = settings.filter_query || '';
                
                const catalogFilters = settings.catalog_filter || {};
                document.querySelectorAll('input[name="catalogs"]').forEach(cb => {
                    cb.checked = !!catalogFilters[cb.value];
                });
            }

            // Set the date to now
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('date').value = today;
        }

        async function fetchAltitudeData(object) {
            try {
                const response = await fetch('http://127.0.0.1:5000/api/altitude_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latitude: document.getElementById('latitude').value,
                        longitude: document.getElementById('longitude').value,
                        ra: object.RA,
                        dec: object.Dec,
                        date: document.getElementById('date').value,
                        timezone: document.getElementById('timezone').value
                    })
                });

                if (!response.ok) throw new Error('Failed to fetch altitude data');

                const data = await response.json();
                showAltitudeGraph(object, data);
            } catch (error) {
                console.error("Error fetching altitude data:", error);
            }
        }

        function parseTimeToMinutes(timeStr, referenceSunsetTime) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            let totalMinutes = hours * 60 + minutes;

            // If the time is after midnight but before sunrise (e.g., 00:30), treat it as the next day.
            if (totalMinutes < referenceSunsetTime) {
                totalMinutes += 1440;  // Add 24 hours in minutes to shift to the next day
            }

            return totalMinutes;
        }

        function showAltitudeGraph(object, data) {
            // Set the modal title dynamically
            const titleElement = document.getElementById('chartTitle');
            const maxAltitude = Math.max(...data.altitudes); // Calculate the max altitude
            titleElement.textContent = `${object.Name.replace(/\s+/g, ' ').trim()} - Transit Time: ${data.transit_time} - Apex: ${maxAltitude.toFixed(1)}°`;

            // Display the graph modal
            document.getElementById('graphModal').style.display = 'block';

            // Get the canvas context
            const ctx = document.getElementById('altitudeChart').getContext('2d');

            // Clear any existing chart on the canvas
            if (window.altitudeChartInstance) {
                window.altitudeChartInstance.destroy();
            }

            // Calculate the minutes from the first time in the data for x-values
            const firstTime = data.times[0];
            const [firstHour, firstMinute] = firstTime.split(':').map(Number);
            const firstTimeInMinutes = firstHour * 60 + firstMinute;

            const timeInMinutes = data.times.map(time => {
                const [hour, minute] = time.split(':').map(Number);
                let totalMinutes = hour * 60 + minute;

                // Adjust times past midnight to ensure continuity
                if (totalMinutes < firstTimeInMinutes) {
                    totalMinutes += 1440; // Add 24 hours in minutes for times after midnight
                }

                return totalMinutes - firstTimeInMinutes;
            });

            // Map event times (dawn, dusk, etc.) to minutes from the first time, scaled for 10-minute intervals
            const sunsetMinutes = (parseTimeToMinutes(data.sunset, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const sunriseMinutes = (parseTimeToMinutes(data.sunrise, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const dawnMinutes = (parseTimeToMinutes(data.astronomical_dawn, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const duskMinutes = (parseTimeToMinutes(data.astronomical_dusk, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const transitMinutes = (parseTimeToMinutes(data.transit_time, firstTimeInMinutes) - firstTimeInMinutes) / 10;
            const midnightMinutes = ((24 * 60 - firstTimeInMinutes) % 1440) / 10; // Calculate midnight position

            const verticalLines = [
                { position: transitMinutes, label: 'Transit', color: 'red' },
                { position: midnightMinutes, label: 'Midnight', color: 'green' },
            ];

            // Custom plugin for shading, vertical lines, and plot adjustments
            // Define the custom plugin for dynamic shading, grid, and labels
            const customPlugin = {
                id: 'customPlugin',
                beforeDraw(chart) {
                    const { ctx, chartArea, scales } = chart;
                    const { left, right, top, bottom } = chartArea;
                    ctx.save();

                    // Shading for background
                    const drawBackground = (start, end, color) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = color;
                        ctx.fillRect(startX, top, endX - startX, bottom - top);
                    };

                    const drawGradient = (start, end, gradient) => {
                        const startX = scales.x.getPixelForValue(start);
                        const endX = scales.x.getPixelForValue(end);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(startX, top, endX - startX, bottom - top);
                    };

                    // Gradient for sunset to dusk
                    const lightToDarkGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(sunsetMinutes),
                        0,
                        scales.x.getPixelForValue(duskMinutes),
                        0
                    );
                    lightToDarkGradient.addColorStop(0, GRADIENT_LIGHT);
                    lightToDarkGradient.addColorStop(1, GRADIENT_DARK);
                    drawGradient(sunsetMinutes, duskMinutes, lightToDarkGradient);

                    // Gradient for dawn to sunrise
                    const darkToLightGradient = ctx.createLinearGradient(
                        scales.x.getPixelForValue(dawnMinutes),
                        0,
                        scales.x.getPixelForValue(sunriseMinutes),
                        0
                    );
                    darkToLightGradient.addColorStop(0, GRADIENT_DARK);
                    darkToLightGradient.addColorStop(1, GRADIENT_LIGHT);
                    drawGradient(dawnMinutes, sunriseMinutes, darkToLightGradient);

                    // Black shading for dusk to dawn
                    drawBackground(duskMinutes, dawnMinutes, 'black');

                    // Draw vertical lines for Transit and Midnight
                    const verticalLines = [
                        { position: transitMinutes, label: 'Transit', color: 'red' },
                        { position: midnightMinutes, label: 'Midnight', color: 'green' },
                        { position: duskMinutes, label: 'Dusk', color: 'rgba(0, 0, 255, 0.4)' },
                        { position: dawnMinutes, label: 'Dawn', color: 'rgba(0, 0, 255, 0.4)' }
                    ];

                    verticalLines.forEach(line => {
                        const xPosition = scales.x.getPixelForValue(line.position);

                        // Draw vertical line
                        ctx.beginPath();
                        ctx.moveTo(xPosition, top);
                        ctx.lineTo(xPosition, bottom);
                        ctx.strokeStyle = line.color;
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw label above the chart
                        ctx.fillStyle = line.color;
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(line.label, xPosition, top - 10);
                    });

                    // Horizontal grid lines dynamically
                    const yTicks = scales.y.ticks;

                    yTicks.forEach((tick) => {
                        const yPosition = scales.y.getPixelForValue(tick.value);

                        // Daytime: left to dusk
                        ctx.beginPath();
                        ctx.moveTo(left, yPosition);
                        ctx.lineTo(scales.x.getPixelForValue(duskMinutes), yPosition);
                        ctx.strokeStyle = GRID_DAY; // Light gray for daytime
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Nighttime: dusk to dawn
                        ctx.beginPath();
                        ctx.moveTo(scales.x.getPixelForValue(duskMinutes), yPosition);
                        ctx.lineTo(scales.x.getPixelForValue(dawnMinutes), yPosition);
                        ctx.strokeStyle = GRID_NIGHT; // Dark gray for nighttime
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Daytime: dawn to right
                        ctx.beginPath();
                        ctx.moveTo(scales.x.getPixelForValue(dawnMinutes), yPosition);
                        ctx.lineTo(right, yPosition);
                        ctx.strokeStyle = GRID_DAY; // Light gray for daytime
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    });

                    // Add a thick horizontal line at HORIZON_ALTITUDE degrees altitude
                    // Define constants
                    const maxAltitude = scales.y.max; // Maximum value of the y-axis

                    // Draw horizontal line at HORIZON_ALTITUDE if within the visible range
                    if (HORIZON_ALTITUDE <= maxAltitude) {
                        const yHorizon = scales.y.getPixelForValue(HORIZON_ALTITUDE);
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yHorizon);
                        ctx.lineTo(chartArea.right, yHorizon);
                        ctx.strokeStyle = 'green';
                        ctx.lineWidth = 2; // Thicker line
                        ctx.stroke();
                    }

                    // Draw custom x-axis ticks and grid lines
                    // Loop through ticks to draw custom grid and labels
                    const labelPadding = 20; // Space below the graph for labels
                    timeInMinutes.forEach((minute, index) => {
                        const xPosition = scales.x.getPixelForValue(index);

                        // Only draw vertical grid lines at hourly intervals
                        if (minute % 60 === 0) {
                            const isNight = minute >= duskMinutes && minute <= dawnMinutes;

                            // Draw vertical line
                            ctx.beginPath();
                            ctx.moveTo(xPosition, top);
                            ctx.lineTo(xPosition, bottom);
                            ctx.strokeStyle = isNight ? GRID_NIGHT : GRID_DAY; // Dark gray for night, light gray for day
                            ctx.lineWidth = 1;
                            ctx.stroke();

                            // Draw x-axis hour labels
                            const hour = Math.floor((minute + firstTimeInMinutes) / 60) % 24;
                            ctx.fillStyle = '#808080'; // Text color
                            ctx.font = '12px Arial'; // Adjust font size if necessary
                            ctx.textAlign = 'center';
                            ctx.fillText(`${hour}`, xPosition, bottom + labelPadding); // Position below the axis
                        }
                    });
                    // Draw x-axis title
                    ctx.font = '14px Arial';
                    ctx.fillStyle = '#808080'; // Light gray text color for title
                    ctx.textAlign = 'center';
                    ctx.fillText('Local Time (HH)', (chartArea.left + chartArea.right) / 2, chartArea.bottom + 35);


                    // Draw plot line dynamically
                    const data = chart.data.datasets[0].data;

                    for (let i = 0; i < data.length - 1; i++) {
                        const xStart = scales.x.getPixelForValue(i);
                        const yStart = scales.y.getPixelForValue(data[i]);
                        const xEnd = scales.x.getPixelForValue(i + 1);
                        const yEnd = scales.y.getPixelForValue(data[i + 1]);

                        // Determine the zone for the segment
                        const isDarkZone = i >= duskMinutes && i <= dawnMinutes;
                        const isBelowHorizon = data[i] < HORIZON_ALTITUDE || data[i + 1] < HORIZON_ALTITUDE;
                        ctx.strokeStyle = isBelowHorizon ? '#c0c0c0' : isDarkZone ? '#ffffff' : '#c0c0c0'; // Adjust colors dynamically

                        ctx.beginPath();
                        ctx.moveTo(xStart, yStart);
                        ctx.lineTo(xEnd, yEnd);
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            };

            // Chart.js Configuration
            window.altitudeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeInMinutes,
                    datasets: [{
                        data: data.altitudes,
                        borderWidth: 1,
                        pointRadius: 0, // Remove circles on plot points
                        borderColor: 'transparent',
                        /*
                        borderColor: function(context) {
                            const xValue = context.dataIndex/10;
                            return (xValue >= duskMinutes && xValue <= dawnMinutes) ? '#ffffff' : '#ffffff'; // Light gray in dark zone
                        },
                        */
                        fill: false,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 2,
                    layout: {
                        padding: {
                            top: 25, // Add space above the graph for labels
                            bottom: 35,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: { display: false },
                    },
                    scales: {
                        y: {
                            title: { display: true, text: 'Altitude (°)' },
                            grid: {
                                color: 'transparent', // Prevent Chart.js from drawing default grid lines
                                drawTicks: false,     // Optional: Prevent ticks on the grid if you want full control
                            }
                        },
                        x: {
                            display: false,
                            title: { display: false, text: 'Local Time (HH)' },
                            grid: {
                                color: 'transparent', // Prevent Chart.js from drawing default grid lines
                                drawTicks: false,     // Optional: Prevent ticks on the grid if you want full control
                            }
                        }
                    }
                },
                plugins: [customPlugin]
            });
        }


        function showContextMenu(x, y, object) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;

            document.getElementById('graphOption').onclick = () => {
                fetchAltitudeData(object);
                closeContextMenu();
            };
        }

        function closeContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        function closeModal() {
            document.getElementById('graphModal').style.display = 'none';
        }

        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu.style.display === 'block' && !contextMenu.contains(e.target)) {
                closeContextMenu();
            }
        });
    </script>
</head>
<body>
    <div id="resultsContainer">
        <h1>TonightSky v1.0</h1>
        <form onsubmit="event.preventDefault(); listObjects();" id="topForm">
            <div class="form-row">
                <label class="label-input">Latitude: <input type="text" id="latitude" value="-33.713611"></label>
                <label class="label-input">Longitude: <input type="text" id="longitude" value="151.090278"></label>
                <label class="label-input">Timezone: <input type="text" id="timezone" value="Australia/Sydney"></label>
            </div>
            
            <!-- Second Row: Date, Local Time, LST -->
            <div class="form-row">
                <label class="label-input">Date: <input type="date" id="date"></label>
                <label class="label-input">Local Time: <input type="time" id="local_time" value="22:00"></label>
                <label class="label-input">LST: <span id="lst_display">00:00:00</span></label>
            </div>
            
            <!-- Third Row: Catalog Filters -->
            <div class="form-row">
                <span class="label">Catalog:</span>
                <label><input type="checkbox" name="catalogs" value="Messier" checked> Messier</label>
                <label><input type="checkbox" name="catalogs" value="NGC"> NGC</label>
                <label><input type="checkbox" name="catalogs" value="IC"> IC</label>
                <label><input type="checkbox" name="catalogs" value="Caldwell"> Caldwell</label>
                <label><input type="checkbox" name="catalogs" value="Abell"> Abell</label>
                <label><input type="checkbox" name="catalogs" value="Sharpless"> Sharpless</label>
            </div>
            
            <!-- Fourth Row: Filter Query -->
            <div class="form-row full-width">
                <label>Filter Query:</label>
                <input type="text" id="filter_expression" class="wide-input" placeholder="e.g., altitude > 30 and magnitude < 6">
            </div>
                
            <!-- Button Row -->
            <div class="button-row">
                <button type="submit">
                    List Objects
                </button>
            </div>
        </form>

        <!-- Results Table -->
        <div id="tableContainer">
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th onclick="sortTableByColumn(0)">Name</th>
                        <th onclick="sortTableByColumn(1)">RA</th>
                        <th onclick="sortTableByColumn(2)">Dec</th>
                        <th onclick="sortTableByColumn(3)">Transit Time</th>
                        <th onclick="sortTableByColumn(4)">Relative TT</th>
                        <th onclick="sortTableByColumn(5)">Before/After</th>
                        <th onclick="sortTableByColumn(6)">Altitude</th>
                        <th onclick="sortTableByColumn(7)">Azimuth</th>
                        <th onclick="sortTableByColumn(8)">Alt Name</th>
                        <th onclick="sortTableByColumn(9)">Type</th>
                        <th onclick="sortTableByColumn(10)">Magnitude</th>
                        <th onclick="sortTableByColumn(11)">Info</th>
                        <th onclick="sortTableByColumn(12)">Catalog</th>
                    </tr>
                </thead>
                <tbody id="resultsTableBody">
                    <!-- Rows will be dynamically appended here -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Chart Modal -->
    <div id="graphModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3 id="chartTitle" class="chart-title"></h3> <!-- Title outside the chart -->
            <canvas id="altitudeChart"></canvas>
        </div>
    </div>

    <!-- Context Menu for right-click actions -->
    <div id="contextMenu" style="display: none; position: absolute; background: #fff; border: 1px solid #ccc; z-index: 1000;">
        <div id="graphOption" style="padding: 8px; cursor: pointer;">Graph</div>
    </div>

    <div id="loadingPopup">
        <div class="loading-icon"></div>
        <p>Loading data, please wait...</p>
        <div class="help-text">
            <!-- Tips -->
            <p class="tip"><strong>Tip:</strong> Double-click to go to Astrobin</p>
            <p class="tip"><strong>Tip:</strong> Right-click to show an altitude graph</p>
            
            <!-- Notes -->
            <p class="note"><strong>Note:</strong> Loading a large catalog (e.g., 10,000 objects) may take 50+ seconds.</p>
            <p class="note"><strong>Note:</strong> Objects with -ve altitude at the nominated time are not included in the results.</p>
        </div>
    </div>
</body>
</html>
